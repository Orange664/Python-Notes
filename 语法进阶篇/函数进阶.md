### 作用域

#### 定义：

就是作用的范围(也叫做名称空间)；

按照生效的范围来看，又分为全局作用域和局部作用域。

#### 命名空间：

本质是从名称到对象的映射，是一一对应的关系，通过字典来实现。

###### a = 10 定义这个变量时，python会申请内存空间存放10.然后将名字a与10绑定关系存放在名称空间中。

#### 如何清楚绑定关系：

###### del(a)

#### 名称空间

##### 内置名称空间：

随着python解释器启动而产生，停止而回收。第一个被加载。

##### 全局名称空间：

随着所在执行文件，执行结束而回收。第二个被加载。

##### 局部名称空间：

随着函数的调用而产生，结束而回收。如函数的参数、函数内定义的名字。

#### 全局作用域：

包含内置命名空间和全局命名空间。

#### 局部作用域：

在函数内可以使用。

#### python查找变量的顺序

局部的命名空间 ---> 全局命名空间 ---> 内置命名空间

### 变量的作用域

#### 局部变量：

作用范围在函数内部，不同的函数可以定义相同的局部变量。

```py
def funa():
    a = 1
    print('funa第一次的值：%s' % a)
    a = 2
    print('funa第二次的值：%s' % a)
def funb():
    a = 3
    print('funb第二次的值：%s' % a)

funa()
funb()

funa第一次的值：1
funa第二次的值：2
funb第二次的值：3
```

####  全局变量：

作用范围：整个.py文件

既能够在一个函数中使用，也能在其他函数中使用。

```py
li = []     #li为全局变量
for i in range(5):
    li.append(i)
    print(li)
print(li)
```

```python
a = 10      #a为全局变量
def funa():
    print(a)    #10

def funb():
    print(a)    #10

funa()
funb()
```

```py
a = 10      #a为全局变量
def funa():
    a = 20		#此处的a为与全局变量同名的局部变量
    print(a)    #20  先从局部变量查找
def funb():
    print(a)    #10	  a = 20是局部变量，只能在一个函数内部使用。所以这里依旧是全局变量的值。
funa()
funb()
```

#### global、nonlocal

###### global：

将变量声明为全局变量，语法格式：global 变量名。

###### nonlocal：

将变量声明为外层变量(外层函数的局部变量，而且不能是全局变量)

#####  global

a为不可变对象变量

```py
a = 10      #a为全局变量
def funa():
    global a    #把函数内部 a 声明为全局变量
    a = 20      #此处 a 为全局变量，给全局变量重新赋值
    print(a)    #20
def funb():
    print(a)    #20
funa()
funb()
```

```py
a = 1
def fun():
    print(a)    #引用全局变量的值
    a = 2       #此处a是局部变量   报错：UnboundLocalError: cannot access local variable 'a' where it is not associated with a value
fun()
print(a)
```

**变量作用域冲突**：

- 在函数 `fun()` 中，先尝试打印 `a` 的值，然后又给 `a` 赋值 `a = 2`。
- Python 解释器会将函数内部出现赋值操作的变量 `a` 视为局部变量，而非全局变量。
- 这就导致函数内部打印 `print(a)` 时，解释器会去寻找局部变量 `a`，但此时 `a` 尚未被赋值，因此报错。

修改：

```py
a = 1
def fun():
    global a    #声明 a 为全局变量
    print(a)    #引用全局变量的值
    a = 2       #修改全局变量
fun()       #1
print(a)    #2
```

#####  可变对象变量

```py
list1 = [1,2,3,4]   #list1可变对象：修改值，指向的地址是不变的 list1为全局变量
def fun():
    list1[0] = 5    #list1指向的地址没有变化，而值发生了变化。不需要声明即可修改
    print(list1)    #[5, 2, 3, 4]
fun()
```

##### nonlocal

###### 特点：

不能修改全局变量。

在局部作用域中，对父级作用的变量进行引用和修改，并且引用的那层，就从那层开始及以下，此变量全部发生改变。

```py
a = 10
def funa():
    a = 1
    def funb():
        nonlocal a      # a为外层的局部变量 a = 1
        print('funb函数中的a的值：',a)
        a = 2
    funb()
    print('funa函数中a的值：',a)
funa()
print(a)    #全局变量

funb函数中的a的值： 1
funa函数中a的值： 2
10
```

### 匿名函数

应用场景：对简单函数的定义

#### 格式：

语法： 函数名 = lambda 形参：返回值

lambda 是定义匿名函数的关键字，相当于函数的def。

调用：结果 = 函数名(实参)

形参的数量按需添加，加多少都可以，只要用逗号隔开即可。

```py
#求和函数
def func(a,b):
    return a + b
print(func(1,2))

#匿名函数
funa = lambda a,b :a+b
print(funa(1,2))
#匿名函数更加简便
#3
#3
```

```py
#在字符串中，返回索引中为0和2对应的元素
str1 = 'abcde'
#法一
a = []
a.append(str1[0])
a.append(str1[2])
print(a)    #['a', 'c']
#法二
func = lambda x : [x[0],x[2]]
print(func('abcde'))     #['a', 'c']
```

练一练：

```py
#if - else 的使用
a = 4
b = 3
print(a) if a>b else print(b)   #4
#三目运算：  表达式1或结果1 if 条件 else 表达式2或结果2

#匿名函数实现上例
func = lambda x,y:x if x > y else y
print(func(4,3))    #4

#求平方
funa = lambda a : a**2
print(funa(10))
```

### 内置函数

print( )	屏幕输出

set( )	创建一个无序不重复元素集

list( )	将一个可迭代对象转换成列表

tuple( )	将一个可迭代对象转换成元组

abs( )	返回绝对值

sum( )	求和

min( ) / max( )	求最小值/最大值

zip( )	将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组。

map( )	可以对可迭代对象中的每一个元素进行映射，分别取执行。

reduce( )	对参数序列中元素进行累计运算

```py
#abs返回绝对值
print(abs(-3))  #3
#sum求和
print(sum([1,2,3])) #6
#min 求最小值
print(min([1,2,3])) #1
#max 求最大值
print(max([1,2,3])) #3
```

```py
#zip()拉链函数 将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的内容
a = [1,2,3]
b = ['a','b','c']
print(list(zip(a,b)))   #[(1, 'a'), (2, 'b'), (3, 'c')]

#每个变量元素个数不一致时，按最短的来打包元素
c = [1,2,3]
d = ['a','b','c','d']
e = (6,5,4,3,2,1)
for i in zip(a,b,c):
    print(i)
    
(1, 'a', 1)
(2, 'b', 2)
(3, 'c', 3)
```

```py
#map 函数
#map(function,iterable) 映射函数
#作用：可以对可迭代对象中的每一个元素进行映射，分别执行function

#计算列表中每个元素的平方，返回新列表
li = [1,2,3,4]
def funa(x):
    return x*x
mp = map(funa,li)
print(list(mp)) #[1, 4, 9, 16]

#使用匿名函数
print(list(map(lambda x:x*x,li)))   #[1, 4, 9, 16]
```

```py
#reduce() 减少 降低 可迭代中通过计算使元素不断减少，最终得到一个计算值
#reduce(函数名，可迭代对象)
from functools import reduce    #导入模块
def func(x,y):
    return x+y
res = reduce(func,[1,2,3,4])    #求累计和
print(res)      #10

#用匿名函数
l = reduce(lambda x,y:x+y,[1,2,3,4])
print(l)    #10
```

```py
#enumerate 枚举
#用于将一个可遍历的数据对象组合为一个索引序列，同时列出数据和数据下标，一般用在for循环当中
# enumerate(可迭代对象，[start = 0])
li = ['a','b','c','d']
for i,j in enumerate(li):
    print(i,j)
#0 a
#1 b
#2 c
#3 d

print(list(enumerate(li)))      #[(0, 'a'), (1, 'b'), (2, 'c'), (3, 'd')]
print(dict(enumerate(li)))      #{0: 'a', 1: 'b', 2: 'c', 3: 'd'}
```

### 拆包

#### 定义

对于函数中的多个返回数据，去掉元组，列表或者字典，直接获取里面数据的过程。

除了对元组拆包之外，还可以对列表、字典等拆包。

```py
def test():
    a = 10
    b = 20
    c = 30
    return a,b,c
print(test())   #return返回多个值。以元组形式返回到函数的调用处 (10,20,30)
#(10, 20, 30)

a1,b1,c1 = test()	#以元组形式返回到函数的调用处		a1，b1，c1 = (10，20，30) 拆包的过程
print(a1)
print(b1)
print(c1)
10
20
30
```

#### 元组拆包升级版

```py
tu = (1,2,3,4)
a,*c,b = tu     #拆包  a,*c,b = (1,2,3,4)     多变量的赋值
print(f'a = {a}')   #a = 1
print(f'b = {b}')   #b = 4
print(f'c = {c}')   #c = [2, 3]
```

#### 其他数值类型拆包

```py
#列表拆包
a,*b = 1,2,3
print(a)    #1
print(b)    #[2, 3]

#字典拆包
dic = {'name':'tom','age':18,'gender':'女'}
a,b,c = dic
print(a,b,c)    #name age gender
#注意：对字典拆包后获取的是字典的key，没有value
```