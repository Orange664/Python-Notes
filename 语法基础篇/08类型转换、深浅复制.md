### 类型转换

####  6大标准数据类型

Number	     数字(数值)：int float bool complex

String	         字符串	str()

List		     列表		list()

Tuple		 元组		tuple()

Set		     集合		set()

Dictionary	字典		dict()

#### 类型转换特性

想要获取什么类型，就用什么样的函数即可

```py
a = 10
print(type(a))#<class 'int'>
b = str(a)
print(b,type(b))#10 <class 'str'>

list1 = [1,2]
print(type(list1))  #<class 'list'>
t1 = tuple(list1)
print(t1,type(t1))  #(1, 2) <class 'tuple'>
```

```py
#dict()  转换为字典
a = ['a','b','c','d']
b = ['e','f','g']
d = zip(a,b)    #用zip把两个列表进行打包绑定，然后再转换成字典
print(d)    #返回的是对象地址   <zip object at 0x000002154AA0E900>
print(dict(d))  #{'a': 'e', 'b': 'f', 'c': 'g'}
```

### 深浅复制(拷贝)

#### 传递引用、变量的定义

```py
a=10
b=10
print(id(a))    #id(a)查看a的内存地址  #140714557590232
print(id(b))        #140714557590232
#当两个变量的数值相同时，他们共用一个存放数值的内存空间
#也就是b没有重复去存放10这个数据，而是引用了a的内存地址。即b = 10的指针实际上是指向了a的内存地址。-----节省内存空间
```

#### 拷贝

```py
import copy
a = [1,2,3,4,5]
a_copy = copy.copy(a)   #复制a的信息
print(a_copy)   #[1, 2, 3, 4, 5]
print(id(a))    #1801953874496
print(id(a_copy))#1801953919360
#拷贝后，内存地址不同，这是和引用的区别
```

拷贝：备份，就是在内存中开辟一个空间、存储相同的值。

应用场景：给数据做备份，提高数据安全性(降低数据丢失风险)

特点：数据相同，地址不同

#### 深拷贝：外层的对象和内部的元素都拷贝(赋值)了一遍

```py
#深复制
import copy
a = [1,2,3,[4,5,6]]     #两层数据列表
#深拷贝a的值
a_deepcopy = copy.deepcopy(a)
print(a_deepcopy)   #[1, 2, 3, [4, 5, 6]]
print(id(a))    #3068596175232
print(a_deepcopy,id(a_deepcopy))    #[1, 2, 3, [4, 5, 6]] 3068597784128

#修改原数据a第一层元素的值时，查看a_deepcopy数据的变化
a[2] = 100
print(a)    #[1, 2, 100, [4, 5, 6]]
print(a_deepcopy)   #[1, 2, 3, [4, 5, 6]]
#改变a的第一层元素，复制后的数据不会随着变化

#修改原数据a第二层元素的值时，查看a_deepcopy数据的变化
a[3][1] = 10
print(a)    #[1, 2, 100, [4, 10, 6]]
print(a_deepcopy)   #[1, 2, 3, [4, 5, 6]]
#deepcopy()修改原数据不会对复制后的数据产生影响
```

#### 浅拷贝：拷贝了最外层的对象，内部的元素只拷贝了一个引用

数据半共享，复制数据会独立存放，但是只拷贝成功到原数据的第一层，（也就是拷贝后的第二层数据会随原数据改变）。

```py
import copy
a = [1,2,3,[4,5,6]]
a_copy = copy.copy(a)
print(a,id(a))  #[1, 2, 3, [4, 5, 6]] 2738215698816
print(a_copy,id(a_copy))    #[1, 2, 3, [4, 5, 6]] 2738217307712

#修改原数据a第一层的值，查看备份数据是否发生变化
a[0] = 5
print(a)    #[5, 2, 3, [4, 5, 6]]
print(a_copy)   #[1, 2, 3, [4, 5, 6]]

#修改原数据a第二层的值，查看备份数据是否发生变化----会随之发生变化
a[3][1] = 100
print(a)    #[5, 2, 3, [4, 100, 6]]
print(a_copy)   #[1, 2, 3, [4, 100, 6]]
```

##### 小结：

深拷贝：完全复制，原数据发生变化，备份数据不会有任何影响 ---如日常备份。

浅拷贝：半复制半数据共享，原数据第二层发生变化，备份数据也会随之发生变化。

​		应用场景---如日常办公时，在一个表时给链接另一个表的数据，希望一个表数据更新，另一个表也能数据更新。(需要实时同步更新的时候)

### 不可变对象

存储空间保存的数据不允许被修改，这种数据就是不可变类型。

针对的是值(数据内容)来说的，内容不可变，数据更新需要重新分配内存空间。

不可变对象的地址的值是不能修改的，如果修改了这个对象的值，它指向的地址也会变化。在实际应用中，尽量使用不可变对象，代码更安全。

#### 常见的不可变类型：

数值类型：int、bool、float、complex

字符串：str

元组：tuple

```py
i = 73
print(i)        #73
print(type(i))      #<class 'int'>
print(id(i))        #140715106915000

i += 2
print(i)            #75
print(id(i))        #140715106915064

# 不能直接在73这个值上做出改变，而是开辟一个新空间，i = 75.内容：73不可变。
```

### 可变对象

存储空间保存的数据允许被修改，这种数据就是可变类型。

存储的数据内容可以在现有的存储空间直接被修改。

内容可变，地址不变。

#### 常见的可变类型有：

列表：list

字典：dict

集合：set

```py
#列表
m = [5,9]
print(m)    #[5, 9]
print(id(m))    #1308849389952
m += [6]
print(m)    #[5, 9, 6]
print(id(m))    #1308849389952

#集合
set1 = {1,2,'123'}
print(set1,type(set1),id(set1))     #{1, 2, '123'} <class 'set'> 2330654597056
#在集合添加元素
set1.add(100)
print(set1,type(set1),id(set1))     #{1, 2, 100, '123'} <class 'set'> 2330654597056
```

